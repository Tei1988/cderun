# cderun 実装ガイド

## 概要

このドキュメントは`cderun`の実装を段階的に進めるためのガイドです。
各ステップは依存関係を考慮して順序付けられており、前のステップが完了してから次に進みます。

## 現在の実装状況

### 実装済み
- 基本的なCLI構造（Cobra使用）
- 厳密な引数解析（`--tty`, `--interactive`, `--network`, `--mount-socket`, `--mount-cderun`, `--image`, `--runtime`, `--env`, `--volume`, `--workdir`, `--sync-workdir`, `--mount-tools`, `--mount-all-tools`）
- ポリグロットエントリーポイント（シンボリックリンク検出）
- 基本的なコンテナ実行（Docker API使用）
- コンテナのライフサイクル管理（作成・起動・待機・削除）
- 標準入出力のアタッチ（TTY/インタラクティブ対応）
- 設定ファイル読み込み（`.cderun.yaml`, `.tools.yaml`）
- イメージマッピング（サブコマンドからイメージ名の解決）
- 優先順位解決ロジック（CLI, Env, YAML, Defaults）
- ドライランモード（`--dry-run` による設定のプレビュー）
- 環境変数処理（パススルー）
- 作業ディレクトリ同期
- ソケット・バイナリマウント、ツールマウント

### 未実装
- Podmanサポート
- 詳細ログ・デバッグ機能

## 実装フェーズ

### Phase 1: コア機能（必須）
基本的なコンテナ実行機能を実装

### Phase 2: 設定管理
設定ファイルとイメージマッピング

### Phase 3: 高度な機能
環境変数、マウント機能など

### Phase 4: 利便性向上
ドライラン、ログなど

---

## Phase 1: コア機能

### Step 1.1: 中間表現（ContainerConfig）の定義

**目的**: すべての設定を統一的に扱うための中間表現を定義。CLIフラグや設定ファイルの内容をこの構造体に集約する。

**実装内容**:
- `internal/container` パッケージに、イメージ名、コマンド、引数、実行オプション（TTY等）、ボリュームマウント、環境変数、作業ディレクトリ、実行ユーザーを保持する構造体を定義。

**完了条件**:
- `ContainerConfig` 構造体が定義され、必要なフィールドが揃っていること。

---

### Step 1.2: ランタイムインターフェースの定義

**目的**: 複数のコンテナランタイム（Docker, Podman等）を統一的に扱うための抽象化レイヤーを定義。

**実装内容**:
- `internal/runtime` パッケージに、コンテナの作成、起動、待機、削除、および標準入出力へのアタッチを定義した `ContainerRuntime` インターフェースを作成。

**完了条件**:
- インターフェースが定義され、ランタイムの実装を差し替え可能な構成になっていること。

---

### Step 1.3: Docker API実装

**目的**: Docker Engine API (`moby`) を使用してランタイムインターフェースを実装。

**実装内容**:
- `ContainerConfig` を Docker API の `Config`, `HostConfig`, `Mount` 等に変換するロジックを実装。
- コンテナのライフサイクル（Create, Start, Wait, Remove）と入出力ストリームのアタッチ（Attach）を実装。

**完了条件**:
- Docker API 経由でコンテナの作成から終了待機までが実行できること。

---

### Step 1.4: 基本的なコンテナ実行フロー

**目的**: CLIからコンテナを実際に実行。

**実装内容**:
- `internal/command/root.go` の `RunE` ハンドラを実装。
- 引数からサブコマンドとパススルー引数を抽出し、`ContainerConfig` を構築。
- ランタイムを初期化し、コンテナの作成、起動、アタッチ、終了待機を順に呼び出す。
- コンテナの終了コードを受け取り、プロセスの終了コードとして反映させる。

**完了条件**:
- `cderun` を実行した際に、指定したコマンドがコンテナ内で実行され、結果がホストの標準出力に表示されること。
- TTY（`--tty`）やインタラクティブモード（`-i`）が機能すること。

---

## Phase 2: 設定管理

### Step 2.1: 設定ファイル読み込み

**目的**: `.cderun.yaml`（グローバル設定）と `.tools.yaml`（ツール別設定）を読み込む。

**実装内容**:
- `internal/config` パッケージを作成し、YAMLをパースするための構造体を定義。
- 設定ファイルを特定の検索順序（カレントディレクトリ、ホームディレクトリ、システム設定ディレクトリ）に従って探索し、読み込む機能を実装。

**完了条件**:
- 各設定ファイルが正しくパースされ、プログラム内で利用可能な状態になっていること。

---

### Step 2.2: イメージマッピング

**目的**: ユーザーが入力したサブコマンド名（例: `node`）から、対応するコンテナイメージを解決する。

**実装内容**:
- ハードコードされたデフォルトマッピングと、設定ファイル（`.tools.yaml`）で定義されたカスタムマッピングを組み合わせてイメージ名を決定するロジックを実装。

**完了条件**:
- サブコマンド名に応じた適切なイメージが選択され、コンテナが実行されること。

---

### Step 2.3: 優先順位解決

**目的**: CLIフラグ、環境変数、ツール別設定、グローバルデフォルト、ハードコードされたデフォルトの順で設定を解決する。

**実装内容**:
- 各設定項目（TTY、ネットワーク等）について、優先順位階層（P1〜P5）に従って最終的な値を決定するリゾルバーを実装。

**完了条件**:
- 複数の場所で設定が競合した場合に、定義された優先順位に従って正しく値が選択されること。

---

## Phase 3: 高度な機能

### Step 3.1: 環境変数パススルー

**目的**: ホストの環境変数をコンテナに引き継ぐ。

**実装内容**:
- `KEY=value` 形式（直接指定）と `KEY` 形式（ホストから取得）の両方を解決し、`ContainerConfig.Env` に追加するロジックを実装。

**完了条件**:
- 指定した環境変数がコンテナ内のプロセスに正しく渡されていること。

---

### Step 3.2: 作業ディレクトリ同期

**目的**: ホストのカレントディレクトリをコンテナ内の同じパスにマウントし、作業ディレクトリとして設定する。

**実装内容**:
- `os.Getwd()` で取得したパスを、ボリュームマウントおよび `Workdir` 設定として `ContainerConfig` に追加。

**完了条件**:
- コンテナ内からホストのファイルにアクセスでき、相対パスが正しく機能すること。

---

### Step 3.3: ソケットマウント

**目的**: コンテナ内からホストの Docker/Podman を操作可能にする。

**実装内容**:
- 指定されたソケットパスをコンテナ内にバインドマウントする。

**完了条件**:
- コンテナ内で `docker ps` 等のコマンドが正常に動作すること。

---

### Step 3.4: cderunバイナリマウント

**目的**: コンテナ内でも `cderun` コマンドを使用可能にする。

**実装内容**:
- ホスト上の `cderun` バイナリをコンテナ内の `/usr/local/bin/cderun` 等にマウントする。ターゲットのアーキテクチャに合わせたバイナリの準備が必要な場合がある。

**完了条件**:
- コンテナ内から `cderun` が呼び出せること。

---

### Step 3.5: ツールマウント

**目的**: `node` や `python` といった名前で `cderun` を呼び出せるよう、エイリアス（シンボリックリンクまたはバイナリのコピー）をコンテナ内に配置する。

**実装内容**:
- `cderun` バイナリを複数の名前でコンテナ内にマウントまたはリンク作成する。

**完了条件**:
- コンテナ内で `node --version` 等を実行した際に、コンテナ内の `cderun` が起動すること。

---

## Phase 4: 利便性向上

### Step 4.1: ドライランモード

**目的**: 実際のコンテナ実行を行わずに、実行される内容をプレビューする。

**実装内容**:
- `--dry-run` フラグが有効な場合、`ContainerConfig` の内容を人間が読みやすい形式（YAML/JSON等）で標準出力に表示し、実行を中断する。

**完了条件**:
- 実行内容が確認でき、副作用が発生しないこと。

---

### Step 4.2: ログ・デバッグ

**目的**: トラブルシューティングのために詳細な実行ログを表示する。

**実装内容**:
- `--verbose` フラグに応じて、コンテナ作成時のパラメータやランタイムからの応答、内部の処理ステップを標準エラー出力に表示する。

**完了条件**:
- 内部状態が可視化され、デバッグが容易になること。

---

## 実装チェックリスト

### Phase 1 (Completed)
- [x] Step 1.1: ContainerConfig定義
- [x] Step 1.2: Runtimeインターフェース
- [x] Step 1.3: Docker API実装
- [x] Step 1.4: 基本実行フロー

### Phase 2 (Completed)
- [x] Step 2.1: 設定ファイル読み込み
- [x] Step 2.2: イメージマッピング
- [x] Step 2.3: 優先順位解決

### Phase 3 (Completed)
- [x] Step 3.1: 環境変数パススルー
- [x] Step 3.2: 作業ディレクトリ同期
- [x] Step 3.3: ソケットマウント
- [x] Step 3.4: cderunバイナリマウント
- [x] Step 3.5: ツールマウント

### Phase 4
- [x] Step 4.1: ドライランモード
- [ ] Step 4.2: ログ・デバッグ

## 各ステップの完了基準

1. **コードが動作する**: 実装した機能が期待通りに動作
2. **テストが通る**: ユニットテストとインテグレーションテスト
3. **ドキュメントと一致**: featuresドキュメントの仕様通り
4. **エラーハンドリング**: 適切なエラーメッセージ

## 注意事項

- 各ステップは独立してテスト可能にする
- 前のステップが完了してから次に進む
- 既存のコードを壊さない
- featuresドキュメントを常に参照する
